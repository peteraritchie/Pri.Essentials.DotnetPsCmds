---
name: CI
run-name: >
  Build and create release - '${{ github.event.head_commit.message }}',
  from ${{ github.ref }} by @${{ github.actor }}

on:  # yamllint disable-line rule:truthy
  push:
    branches:
      - main
      - develop
    paths:
      - '!.github/**'
      - '.github/workflows/ci.yaml'
      - '.github/workflows/dotnet-build-and-verify.yaml'
      - 'src/**'
      - '!src/Tests/**'
      - '!src/.editorconfig'

  workflow_dispatch:
    inputs:
      dry-run:
        description: "Use dry-run when publishing"
        required: false
        type: boolean
        default: false
      cd-disabled:
        description: "Disable CD"
        required: false
        type: boolean
        default: false

env:
  dry-run: ${{ (github.event.inputs.dry-run != '' && inputs.dry-run == 'true') && true || false }}

jobs:
  determine-release-notes:
    name: Determine Release Notes
    runs-on: ubuntu-latest
    outputs:
      release-notes: ${{ steps.release-notes.outputs.release-notes }}
    permissions:
      contents: write  # to be able to publish a GitHub release
    steps:
      # Determine the release notes, writing them to a file
      - name: Determine release notes
        id: release-notes
        run: |
          @'
          Added Edit-DotnetProject Cmdlet supporting the following properties:
          - AppendTargetFrameworkToOutputPath
          - AssemblyName
          - GenerateDocumentationFile
          - IntermediateOutputPath
          - LangVersion
          - Nullable
          - OutputType
          - OutputPath
          - RestorePackagesWithLockFile
          - TargetFramework
          - Version
          - VersionPrefix
          - VersionSuffix
          As well as InternalsVisibleTo AssemblyAttribute/SupressMessageAttribute.
          '@ | out-file release-notes.txt;

      - name: Upload Release Notes Artifact
        uses: actions/upload-artifact@v6
        with:
          name: ReleaseNotes
          path: release-notes.txt

  # Determining next release version from current release version
  determine-next-release-version:
    name: Determine next Release version
    uses: ./.github/workflows/determine-next-release-version.yaml
    permissions:
      contents: read  # Required for checking out the code
    secrets:
      token: ${{ secrets.GITHUB_TOKEN }}

  # CI: build and verify tests
  build-and-verify:
    name: Build and verify tests
    needs: [determine-next-release-version, determine-release-notes]
    uses: ./.github/workflows/dotnet-build-and-verify.yaml
    permissions:
      contents: read  # Required for checking out the code
    with:
      configuration: >-
        ${{ vars.CONFIGURATION != '' && vars.CONFIGURATION || 'Release' }}
      dotnet-versions: >-
        ${{ vars.DOTNET_CORE_VERSION != '' && vars.DOTNET_CORE_VERSION || '10.0.x' }}
      version: ${{ needs.determine-next-release-version.outputs.version }}
      release-notes-artifact-name: ReleaseNotes
      source-directory: ./src
      output-artifact-name: Module
      module-guid: ${{ vars.PS_MODULE_GUID }}

  # release
  release:
    name: Release module
    needs:
      - build-and-verify
      - determine-next-release-version
      - determine-release-notes
    runs-on: ubuntu-latest
    permissions:
      contents: write  # to be able to publish a GitHub release
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      # Create a tag for GitHub Releases
      - name: Create Tag
        id: create-tag
        run: |
          git tag v${{ needs.determine-next-release-version.outputs.version }}
          echo "tag=\
            v${{ needs.determine-next-release-version.outputs.version }}" \
            >> $GITHUB_OUTPUT

      # Create a GitHub Release
      - name: Create GitHub Release
        id: create-module-release
        uses: actions/create-release@v1.1.4
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.create-tag.outputs.tag }}
          release_name: Release ${{ steps.create-tag.outputs.tag }}
          body: |
            ${{ needs.determine-release-notes.outputs.release-notes }}
          draft: false
          prerelease: ${{ env.prerelease }}

      # Download Module artifact
      - name: Download artifact for Release
        id: download-artifact
        uses: actions/download-artifact@v7
        with:
          name: Module
          path: ./Module

      # re-zip to add to the Release
      - name: Create Module zip
        run: |
          (cd Module && zip -r Module.zip .)

      # Upload the Module zip as a Release Asset
      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1.0.2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create-module-release.outputs.upload_url }}
          asset_path: Module/Module.zip
          asset_name: Module.zip
          asset_content_type: application/zip

  # publish (publish release binary or artifact?)
  publish:
    name: Publish module to PowerShell Gallery
    environment: PowerShellGallery
    if: ${{ (inputs.cd-disabled != '' && inputs.cd-disabled != 'true' || true) }}
    runs-on: ubuntu-latest
    # use output from build-and-verify but after release is sucessful:
    needs: [build-and-verify, release]
    permissions:
      contents: read  # Required for checking out the code
      actions: read  # Required for access to artifacts
    steps:
      # Download Module artifact
      - name: Download Module artifact for Release
        id: download-artifact
        uses: actions/download-artifact@v7
        with:
          name: Module
          path: ./Pri.Essentials.DotnetPsCmds

      # publish PS module (TODO: Parameterize -WhatIf)
      - name: Publish PowerShell module
        shell: pwsh
        run: >
          Publish-Module -Path "Pri.Essentials.DotnetPsCmds"
          -NuGetApiKey "${{ secrets.NUGET_API_KEY }}"
          -Repository '${{ vars.PS_REPOSITORY }}'
          ${{ (env.dry-run != '' && env.dry-run == 'true') && '-WhatIf' || '' }}
          -Verbose
